""" JupyterLab Zenodo : Updating Zenodo Deposition """

import cgi
import glob, json, re, os
import requests
import sqlite3
from urllib.parse import unquote_plus, parse_qsl
from datetime import datetime
from contextlib import contextmanager

from tornado import escape, gen, web

from notebook.base.handlers import APIHandler

from .base import ZenodoBaseHandler

class ZenodoUpdateHandler(ZenodoBaseHandler):
    """
    A handler that updates your files on Zenodo
    """
    def initialize(self, notebook_dir):
        self.notebook_dir = notebook_dir

    def update_file(self, filename, path_to_file, metadata, access_token):
        """Upload the given file at the given path to Zenodo
           Add included metadata

        Parameters
        ----------
        filename : string
            File to be uploaded to zenodo
        path_to_file : string
            Path to the above file (including file name)
        metadata : dictionary
            As generated by assemble_metadata()
        access_token : string
            Zenodo API token

        Returns
        -------
        string
            Doi of successfully uploaded deposition
                
        Notes
        -----
        - Does not yet have ANY error handling
    
        """

        ACCESS_TOKEN = access_token
        headers = {"Content-Type": "application/json"}
        # Create deposition
        r = requests.post('https://zenodo.org/api/deposit/depositions',
                          params={'access_token': ACCESS_TOKEN}, json={},
                          headers=headers)
        deposition_id = r.json()['id']
        data = {'filename': filename}
        files = {'file': open(path_to_file, 'rb')}
        r = requests.post('https://zenodo.org/api/deposit/depositions/%s/files' % deposition_id,
                          params={'access_token': ACCESS_TOKEN}, data=data,
                          files=files)
        r = requests.put('https://zenodo.org/api/deposit/depositions/%s' % deposition_id,
                         params={'access_token': ACCESS_TOKEN}, 
                         data=json.dumps({'metadata': metadata}),
                         headers=headers)
        r_dict = r.json()
        print(r_dict)
        doi = r_dict.get('doi') 
        if not doi:
            doi = r_dict.get('metadata',{}).get('prereserve_doi',{}).get('doi')
        print("doi: "+str(doi))
        return doi
    
    def store_record(self, doi):
        """Store a record of publication in a local sqlite database
    
        Parameters
        ----------
        doi : string
            Zenodo DOI given to uploaded record
    
        Returns
        -------
            void

        """
        db_dest = "/work/.zenodo/"
        print(os.path.exists(db_dest))
        if not os.path.exists(db_dest):
            cmd = "mkdir" + db_dest
            os.system(cmd)
        conn = sqlite3.connect(db_dest+'zenodo.db')
        c = conn.cursor()
        try:
            c.execute("CREATE TABLE uploads (date_uploaded, doi)")
        except:
            pass
        c.execute("INSERT INTO uploads VALUES (?,?)",[datetime.now(),doi])

        # Commit and close
        conn.commit()
        conn.close()

    @web.authenticated
    @gen.coroutine
    def get(self, path=''):
        print("In GET routine for update handler")
        info = {'status':'executed get in update', 'doi':"no doi here"}
        self.set_status(200)
        self.write(json.dumps(info))
        self.finish()

    @web.authenticated
    @gen.coroutine
    def post(self, path=''):
        self.check_xsrf_cookie()
        print("In POST routine for update handler")

        """
        Takes in a a file prefix string
        Zips notebook_dir to file_prefix.zip, updates on Zenodo
        Returns dictionary with status (success or failure)
        """
        form = cgi.FieldStorage() 
        print("form")
        print(form)
        title = form.getvalue("title")
        file_prefix = form.getvalue("file_prefix") 
        author = form.getvalue("author") 
        print("all these! "+title+author+file_prefix)


        my_body = self.request.body.decode("utf-8")
        print(str(self.request.body))
        print(my_body)
        print(path)
        request_data_str= (str(self.request.body)[2:])[:-1]
        request_data = dict(parse_qsl(request_data_str))

        

        try:
            title = request_data['title']
            print(title)
            file_prefix = request_data['file_prefix']
            print(file_prefix)
            authors = request_data['author']
            description = request_data['description']
            print(description)
        except KeyError:
            print("key error\n\n")
            info = {'status':'failure', 'message':'Missing some data!', 'doi' : None}
            self.set_status(400)
            self.write(json.dumps(info))
            self.finish()
            return

        our_access_token = '***REMOVED***'
        access_token = request_data.get('access_token', our_access_token)
        directory_to_zip = request_data.get('directory','work')

        filename = file_prefix + ".zip"

        self.zip_dir(directory_to_zip, filename)

        path_to_file = directory_to_zip + "/../" + filename
        metadata = self.assemble_metadata(title, authors, description)

        doi = self.upload_file(filename, path_to_file, metadata, access_token) 
        print("done checking stuff now\n\n\n\n")
        if (doi is not None):
            info = {'status':'success', 'doi':doi}
            print("doi: "+str(doi))
            self.set_status(201)
            self.write(json.dumps(info))
            self.store_record(doi)
            #self.redirect("http://127.0.0.1:7000/portal/upload/"+doi)
            self.finish()
        else:
            info = {'status':'failure', 'doi': None}
            print("no doi")
            self.set_status(404)
            self.write(json.dumps(info))
            self.finish()
        
